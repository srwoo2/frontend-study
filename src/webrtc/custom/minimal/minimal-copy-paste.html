<!DOCTYPE html>
<html lang="ko">
<head>
  <script src="/src/webrtc/js/common/set-title.js"></script>
  <script src="/src/webrtc/js/common/utils.js"></script>
</head>
  <style>
    :root {
      --bg-color: #202124;
      --text: #ffffff;
    }
    .video-box {
      position: relative;
    }
    #loadingOverlay {
      position: absolute !important; 
      top: 0; 
      left: 0;
      width: 100%; 
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 5;
    }
  </style>
</head>
<body>
  <div id="container">
    <div class="status-pill">
      <div><span id="statusText">WAITING</span></div>
    </div>

    <div class="split-container">
      <div class="video-box">
        <div class="label">상대방 (Remote)</div>
        <video id="remoteVideo" autoplay playsinline></video>

        <div id="loadingOverlay" class="loading-overlay" style="display: none;">
          <div class="spinner"></div>
        </div>
      </div>
      <div class="video-box">
        <div class="label">나 (Local)</div>
        <video id="localVideo" autoplay playsinline muted></video>
      </div>
    </div>

    <div class="control-bar">
      <button id="startCallBtn" class="btn-primary" onclick="document.getElementById('manualPanel').style.display = 'block'">수동 통화 시작</button>
      <button id="endCallBtn" class="btn-danger" onclick="endCall(); disconnectWss();" style="display:none">통화 종료</button>
      <button id="toggleCameraBtn" class="btn-secondary" onclick="toggleMedia('video')" style="display:none">카메라 On</button>
      <button id="toggleAudioBtn" class="btn-secondary" onclick="toggleMedia('audio')" style="display:none">마이크 On</button>
      <button id="retryBtn" class="btn-primary" onclick="enterWaitingState()" style="display:none">다시 연결</button>
    </div>

    <div id="manualPanel" class="panel" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; background: rgba(32, 33, 36, 0.95); z-index: 100;">
      <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #444; margin-bottom: 15px; padding-bottom: 10px;">
        <h3 style="margin: 0;">수동 WebRTC 연결 방법</h3>
        <button class="btn-small" onclick="document.getElementById('manualPanel').style.display = 'none'">닫기</button>
      </div>
      
      <p class="sub-text" style="color: #aaa;">
        - A에서 “Create Offer” 클릭 → A의 SDP에 Offer 텍스트 생성 및 복사<br/>
        - A의 SDP Offer → B의 SDP에 붙여넣고 “Create Answer” 클릭 → B의 SDP에 Answer 텍스트 생성 및 복사<br/>
        - B의 SDP Answer → A의 SDP에 붙여넣고 “Set Remote Answer” 클릭 → A의 ICE Candidates에 텍스트 생성 및 복사<br/>
        - A의 ICE Candidates → B의 Remote ICE Candidates에 붙여넣고 “Add Remote ICE Candidates” 클릭<br/>
      </p>

      <div class="row">
        <button id="createOffer" class="btn-primary" onclick="handleCreateOffer()">Create Offer</button>
        <button id="createAnswer" class="btn-primary" onclick="handleCreateAnswer()">Create Answer</button>
        <button id="setRemoteAnswer" class="btn-primary" onclick="handleSetRemoteAnswer()">Set Remote Answer</button>
        <button id="addRemoteCandidates" class="btn-primary" onclick="handleAddRemoteCandidates()">Add Remote ICE Candidates</button>
      </div>

      <div class="row">
        <div class="col">
          <h4>SDP (Offer/Answer)</h4>
          <div style="margin-bottom: 8px;">
            <button class="btn-secondary" onclick="copyText('sdpBox')">복사</button>
            <button class="btn-secondary" onclick="pasteText('sdpBox')">붙여넣기</button>
            <button class="btn-secondary" onclick="clearText('sdpBox')">지우기</button>
          </div>
          <textarea id="sdpBox" style="height: 120px; background: #111; color: #0f0;"></textarea>
        </div>
        <div class="col">
          <h4>Local ICE Candidates</h4>
          <div style="margin-bottom: 8px;">
            <button class="btn-secondary" onclick="copyText('localCandidatesBox')">복사</button>
            <button class="btn-secondary" onclick="pasteText('localCandidatesBox')">붙여넣기</button>
            <button class="btn-secondary" onclick="clearText('localCandidatesBox')">지우기</button>
          </div>
          <textarea id="localCandidatesBox" style="height: 120px; background: #111; color: #0f0;"></textarea>
        </div>
        <div class="col">
          <h4>Remote ICE Candidates</h4>
          <div style="margin-bottom: 8px;">
            <button class="btn-secondary" onclick="copyText('remoteCandidatesBox')">복사</button>
            <button class="btn-secondary" onclick="pasteText('remoteCandidatesBox')">붙여넣기</button>
            <button class="btn-secondary" onclick="clearText('remoteCandidatesBox')">지우기</button>
          </div>
          <textarea id="remoteCandidatesBox" style="height: 120px; background: #111; color: #0f0;"></textarea>
        </div>
      </div>
    </div>
  </div>



  <script>
    const elStatusText = document.getElementById('statusText');

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');

    const startCallBtn = document.getElementById('startCallBtn');
    const endCallBtn = document.getElementById('endCallBtn');
    const toggleCameraBtn = document.getElementById('toggleCameraBtn');
    const toggleAudioBtn = document.getElementById('toggleAudioBtn');
    const retryBtn = document.getElementById('retryBtn');

    const sdpBox = document.getElementById('sdpBox');
    const localCandidatesBox = document.getElementById('localCandidatesBox');
    const remoteCandidatesBox = document.getElementById('remoteCandidatesBox');

    const CONFIG = {
      iceServers: { iceServers: [] },
      connectTimeoutMs: 10000
    };

    let pc = null;
    let localStream = null;
    let connectionTimeoutId = null;
    let _call_state = CALL_STATUS.WAITING.id;
    Object.defineProperty(window, 'ws_state', {
      get: function() { return _call_state; },
      set: function(val) {
        _call_state = val;
        updateUiForState();

        // Timeout Logic
        if (connectionTimeoutId && val !== CALL_STATUS.CONNECTING.id) {
          clearTimeout(connectionTimeoutId);
          connectionTimeoutId = null;
        }
      }
    });

    /**
     * 연결 상태 UI 표시
     */
    function updateUiForState() {
      const stateId = CALL_STATUS[ws_state].id || '';
      elStatusText.textContent = CALL_STATUS[ws_state].label || '';

      startCallBtn.style.display = 'none';
      endCallBtn.style.display = 'none';
      retryBtn.style.display = 'none';
      toggleCameraBtn.style.display = 'none';
      toggleAudioBtn.style.display = 'none';

      switch (stateId) {
        case CALL_STATUS.WAITING.id:
          break;
        case CALL_STATUS.IDLE.id:
          startCallBtn.style.display = 'block';
          toggleAudioBtn.style.display = 'block';
          toggleCameraBtn.style.display = 'block';
          break;
        case CALL_STATUS.CONNECTING.id:
        case CALL_STATUS.CONNECTED.id:
          endCallBtn.style.display = 'block';
          toggleAudioBtn.style.display = 'block';
          toggleCameraBtn.style.display = 'block';
          break;
        case CALL_STATUS.ERROR.id:
          retryBtn.style.display = 'block';
          break;
        case CALL_STATUS.DISCONNECTED.id:
        default:
          break;
      }
      
      // 로딩 오버레이 제어
      const overlay = document.getElementById('loadingOverlay');
      if (stateId === CALL_STATUS.CONNECTING.id) {
        overlay.style.display = 'flex';
      } else {
        overlay.style.display = 'none';
      }
    }

    /**
     * 카메라/마이크 권한 요청
     */
    async function checkMediaPermissions() {
      const cameraStatus = await navigator.permissions.query({ name: 'camera' });
      const microphoneStatus = await navigator.permissions.query({ name: 'microphone' });

      if (cameraStatus.state === 'denied') {
        throw new Error(ERRORS.CAMERA_PERMISSION);
      }
      if (microphoneStatus.state === 'denied') {
        throw new Error(ERRORS.MIC_PERMISSION);
      }
    }

    /**
     * 미디어 장치 연결
     */
    async function getMediaStream() {
      if (localStream) return;

      const devices = await navigator.mediaDevices.enumerateDevices();

      const hasCamera = devices.some(d => d.kind === 'videoinput');
      const hasMic = devices.some(d => d.kind === 'audioinput');

      if (!hasCamera) {
        throw new Error(ERRORS.NO_CAMERA);
      }
      if (!hasMic) {
        throw new Error(ERRORS.NO_MIC);
      }

      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      localStream = stream;
      localVideo.srcObject = stream;
    }

    /**
     * RTCPeerConnection(PC) 생성
     */
    function ensurePC() {
      if (pc) return;

      pc = new RTCPeerConnection(CONFIG.iceServers);

      if (localStream) {
        localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));
      }

      const remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;

      pc.ontrack = (event) => {
        console.log('ontrack', event);
        const stream = event.streams?.[0];

        if (stream) {
          stream.getTracks().forEach((t) => remoteStream.addTrack(t));
        } else {
          remoteStream.addTrack(event.track);
        }

        event.track.onmute = () => {
          console.warn("Remote track muted → 수신 중단");
          ws_state = CALL_STATUS.DISCONNECTED.id;
        };

        event.track.onended = () => {
          console.log('Remote track ended');
          ws_state = CALL_STATUS.DISCONNECTED.id;
        };
      };

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          localCandidatesBox.value += JSON.stringify(event.candidate) + '\n';
        }
      };

      pc.oniceconnectionstatechange = () => {
        console.log('ICE state:', pc.iceConnectionState);

        switch (pc.iceConnectionState) {
          case 'checking':
            ws_state = CALL_STATUS.CONNECTING.id;
            break;
          case 'connected':
          case 'completed':
            ws_state = CALL_STATUS.CONNECTED.id;
            break;
          case 'failed':
            break;
          case 'disconnected':
          case 'closed':
            endCall(); // 상대방 연결이 끊어지면 내 통화도 종료
            break;
        }
      };
    }
    
    /**
     * 통화 종료
     */
    function endCall() {
      if (pc) {
        pc.close();
        pc = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      ws_state = CALL_STATUS.DISCONNECTED.id; 

      // UI 초기화
      sdpBox.value = '';
      localCandidatesBox.value = '';
      remoteCandidatesBox.value = '';
    }

    /**
     * 대기 상태 진입
     */
    async function enterWaitingState() {
      try {
        await checkMediaPermissions();
        await getMediaStream();

        ws_state = CALL_STATUS.IDLE.id;
      } catch (e) {
        console.error(e);
        alert(e.message);
        ws_state = CALL_STATUS.ERROR.id;
      }
    }

    /**
     * 미디어 장치 제어
     * @param {string} type 'video' | 'audio'
     */
    function toggleMedia(type) {
      if (!localStream) return;

      const isVideo = type === 'video';
      const tracks = isVideo ? localStream.getVideoTracks() : localStream.getAudioTracks();
      const track = tracks[0];

      if (track) {
        track.enabled = !track.enabled;
        const btn = isVideo ? toggleCameraBtn : toggleAudioBtn;
        const label = isVideo ? '카메라' : '마이크';
        btn.textContent = `${label} ${track.enabled ? 'On' : 'Off'}`;
      }
    }

    // Offer 생성: 수동/WS 병행
    async function handleCreateOffer() {
      try {
        ws_state = CALL_STATUS.CONNECTING.id;

        // Timeout Start
        if (connectionTimeoutId) clearTimeout(connectionTimeoutId);
        connectionTimeoutId = setTimeout(() => {
          endCall();
          handleError(new Error(ERRORS.CONNECTION_TIMEOUT));
        }, CONFIG.connectTimeoutMs);

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        
        ensurePC();
    
        sdpBox.value = JSON.stringify(pc.localDescription);
      } catch (e) {
        console.error(e);
        alert(e.message);
        ws_state = CALL_STATUS.ERROR.id;
      }
    };

    // Answer 생성: 수동/WS 병행
    async function handleCreateAnswer() {
      try {
        ensurePC();

        const remoteOffer = JSON.parse(sdpBox.value.trim());
        await pc.setRemoteDescription(new RTCSessionDescription(remoteOffer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
    
        sdpBox.value = JSON.stringify(pc.localDescription);
      } catch (e) {
        console.error(e);
        alert(e.message);
      }
    }

    // Remote Answer 수동 적용
    async function handleSetRemoteAnswer() {
      try {
        const remoteAnswer = JSON.parse(sdpBox.value.trim());
        await pc.setRemoteDescription(new RTCSessionDescription(remoteAnswer));
        alert('Remote Answer 적용 완료!');
      } catch (e) {
        console.error(e);
        alert(e.message);
      }
    }

    // Remote ICE candidates 수동 적용
    async function handleAddRemoteCandidates() {
      try {
        const lines = remoteCandidatesBox.value
          .split('\n')
          .map((l) => l.trim())
          .filter((l) => !!l);

        for (const line of lines) {
          const candidateObj = JSON.parse(line);
          await pc.addIceCandidate(new RTCIceCandidate(candidateObj));
        }
        alert('Remote ICE candidates 적용 완료!');
      } catch (e) {
        console.error(e);
        alert(e.message);
      }
    }
    
    window.onload = () => {
      updateUiForState();
      enterWaitingState();
    };
    window.onbeforeunload = () => {
      endCall();
    };
    window.onerror = (msg, url, line) => log('ERROR', `Global: ${msg} (${line})`);
  </script>
</body>
</html>
