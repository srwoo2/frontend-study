<!DOCTYPE html>
<html lang="ko">
<head>
  <script src="/src/webrtc/js/common/set-title.js"></script>
  <link rel="stylesheet" href="../../css/main.css">
</head>
<body>
  <h2>Minimal WebRTC í…ŒìŠ¤íŠ¸</h2>

  <!-- UI/UX ê¸°ë³¸ ìš”ì†Œ -->
  <div>
    <div class="row">
      <div class="col">
        <h3>Local</h3>
        <video id="localVideo" autoplay playsinline muted></video>
      </div>
      <div class="col">
        <h3>Remote</h3>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
    </div>

    <div class="row">
      <button id="startCamera">ğŸ¥ Start Camera</button>
    </div>
  </div>

  <!-- WebSocket signaling controls -->
  <div class="panel">
    <h3>Signaling(WebSocket) ì—°ê²°</h3>
    <p class="sub-text">
      - Aì™€ B ëª¨ë‘ í•˜ë‹¨ WS URL ì…ë ¥ë€ì´ wss://localhost:3001ì¸ì§€ í™•ì¸ í›„ â€œConnect WSâ€ í´ë¦­í•˜ì—¬ connected í™•ì¸<br/>
      - disconnectedì¸ ê²½ìš°, <a href="https://192.168.2.95:3001">https://192.168.2.95:3001</a> ì‹œê·¸ë„ë§ ì„œë²„ ì‹ ë¢°ëœ ì‚¬ì´íŠ¸ ì„¤ì •
      - Aì—ì„œ â€œCreate Offerâ€ í´ë¦­<br/>
      - Bì—ì„œ ìë™ìœ¼ë¡œ Answer ì‘ë‹µ, ICE í›„ë³´ ìë™ êµí™˜<br/>
    </p>

    <div class="row">
      <label>
        WS URL:
        <input id="wsUrl" type="text" style="width: 360px;" value="wss://192.168.2.95:3001" />
      </label>
      <button id="connectWs">ğŸ”Œ Connect WS</button>
      <button id="disconnectWs">âŒ Disconnect WS</button>
      <span id="wsStatus">disconnected</span>
    </div>
    <div class="row">
      <button class="createOffer" onclick="handleCreateOffer()">Create Offer</button>
    </div>
  </div>

  <!-- HTTP(SSE) signaling controls -->
  <div class="panel">
    <h3>HTTP(SSE) signaling</h3>
    <p class="sub-text">
      - ì›¹ì„œë²„ 3000 í¬íŠ¸ë¡œ ì ‘ì†<br/>
      - Aì™€ B ëª¨ë‘ ê°™ì€ Room ì…ë ¥ í›„ â€œConnect SSEâ€ í´ë¦­í•˜ì—¬ connected í™•ì¸<br/>
      - Aì—ì„œ â€œCreate Offerâ€ í´ë¦­<br/>
      - Bì—ì„œ ìë™ìœ¼ë¡œ Answer ì‘ë‹µ, ICE í›„ë³´ ìë™ êµí™˜<br/>
    </p>

    <div class="row">
      <label>
        Room:
        <input id="roomInput" type="text" style="width: 180px;" value="default" />
      </label>
      <button id="connectSse">ğŸ”Œ Connect SSE</button>
      <button id="disconnectSse">âŒ Disconnect SSE</button>
      <span id="sseStatus">disconnected</span>
    </div>
    <div class="row">
      <button class="createOffer" onclick="handleCreateOffer()">Create Offer</button>
    </div>
  </div>

  <!-- ìˆ˜ë™ WebRTC ì—°ê²° -->
  <div class="panel">
    <h3>ìˆ˜ë™ WebRTC ì—°ê²°</h3>
    <p class="sub-text">
      - Aì—ì„œ â€œCreate Offerâ€ í´ë¦­ â†’ Aì˜ SDPì— Offer í…ìŠ¤íŠ¸ ìƒì„±<br/>
      - Aì˜ SDP Offer í…ìŠ¤íŠ¸ë¥¼ Bì˜ SDPì— ë¶™ì—¬ë„£ê³  â€œCreate Answerâ€ í´ë¦­ â†’ Bì˜ SDPì— Answer í…ìŠ¤íŠ¸ ìƒì„±<br/>
      - Bì˜ SDP Answer í…ìŠ¤íŠ¸ë¥¼ Aì˜ SDPì— ë¶™ì—¬ë„£ê³  â€œSet Remote Answerâ€ í´ë¦­ â†’ Aì˜ ICE Candidatesì— í…ìŠ¤íŠ¸ ìƒì„±<br/>
      - Aì˜ ICE Candidates í…ìŠ¤íŠ¸ë¥¼ ë³µì‚¬ â†’ Bì˜ Remote ICE Candidatesì— ë¶™ì—¬ë„£ê³  â€œAdd Remote ICE Candidatesâ€ í´ë¦­<br/>
    </p>

    <div class="row">
      <button class="createOffer" onclick="handleCreateOffer()" title="RTCPeerConnectionì„ ë§Œë“¤ê³ , ë‚´ ì—°ê²° ì €ì¥ë¥¼ ë‹´ì€ Offer(SDP)ë¥¼ ìƒì„±í•´ ìƒëŒ€ì—ê²Œ ë³´ë‚´ê¸° ìœ„í•œ ì´ë²¤íŠ¸">Create Offer</button>
      <button id="createAnswer" title="ìƒëŒ€ê°€ ë³´ë‚¸ Offerë¥¼ ë°›ì•„ì„œ, ë‚´ê°€ ì—°ê²°í•  ì¤€ë¹„ê°€ ë˜ì—ˆë‹¤ëŠ” Answer(SDP)ë¥¼ ìƒì„±í•˜ëŠ” ì´ë²¤íŠ¸">Create Answer</button>
      <button id="setRemoteAnswer" title="ìƒëŒ€ê°€ ë³´ë‚¸ Answer(SDP)ë¥¼ ë‚´ RTCPeerConnectionì— ì ìš©í•˜ëŠ” ì´ë²¤íŠ¸">Set Remote Answer</button>
      <button id="addRemoteCandidates">Add Remote ICE Candidates</button>
    </div>

    <div class="row">
      <div class="col">
        <h4>SDP (Offer/Answer)</h4>
        <textarea id="sdpBox"></textarea>
      </div>
      <div class="col">
        <h4>ICE Candidates</h4>
        <textarea id="localCandidatesBox"></textarea>
      </div>
      <div class="col">
        <h4>Remote ICE Candidates</h4>
        <textarea id="remoteCandidatesBox"></textarea>
      </div>
    </div>
  </div>

  <script>
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');

    const startBtn = document.getElementById('startCamera');
    const createAnswerBtn = document.getElementById('createAnswer');
    const setRemoteAnswerBtn = document.getElementById('setRemoteAnswer');
    const addRemoteCandidatesBtn = document.getElementById('addRemoteCandidates');

    const sdpBox = document.getElementById('sdpBox');
    const localCandidatesBox = document.getElementById('localCandidatesBox');
    const remoteCandidatesBox = document.getElementById('remoteCandidatesBox');

    let pc;
    let localStream;

    const configuration = {
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    };

    // WebSocket signaling
    let connectWsBtn, disconnectWsBtn, wsStatusSpan, wsUrlInput;
    let ws = null;

    // HTTP(SSE) signaling
    let connectSseBtn, disconnectSseBtn, sseStatusSpan, roomInput;
    let sse = null;
    const clientId = (() => {
      try {
        const arr = new Uint8Array(16);
        (crypto && crypto.getRandomValues) ? crypto.getRandomValues(arr) : arr.fill(0);
        return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
      } catch (_) {
        return String(Date.now()) + '-' + Math.random().toString(16).slice(2);
      }
    })();

    function setWsStatus(connected) {
      wsStatusSpan.textContent = connected ? 'connected' : 'disconnected';
      wsStatusSpan.style.color = connected ? 'green' : 'red';
    }

    function setSseStatus(connected) {
      sseStatusSpan.textContent = connected ? 'connected' : 'disconnected';
      sseStatusSpan.style.color = connected ? 'green' : 'red';
    }

    function buildWsUrl(raw) {
      console.log(raw)

      const input = (raw || '').trim();
      const pageIsHttps = location.protocol === 'https:';
      const defaultScheme = pageIsHttps ? 'wss' : 'ws';
      const defaultPort = 3001;

      if (!input) {
        return `${defaultScheme}://${location.hostname}:${defaultPort}`;
      }

      try {
        const u = new URL(input);
        if (u.protocol === 'http:' || u.protocol === 'https:') {
          u.protocol = pageIsHttps ? 'wss:' : 'ws:';
        }
        if (u.protocol !== 'ws:' && u.protocol !== 'wss:') {
          throw new Error('Unsupported protocol');
        }
        if (!u.port) {
          u.port = String(defaultPort);
        }
        return u.toString();
      } catch (_) {
        const hasPort = /:\d+$/.test(input);
        const host = input;
        const portPart = hasPort ? '' : `:${defaultPort}`;
        return `${defaultScheme}://${host}${portPart}`;
      }
    }

    function toHttpsUrl(wsUrl) {
      try {
        const u = new URL(wsUrl);
        u.protocol = 'https:';
        return u.toString();
      } catch (_) {
        return '';
      }
    }

    async function preflightHttps(url) {
      if (!url) return false;
      try {
        await fetch(url, { mode: 'no-cors' });
        return true;
      } catch (_) {
        return false;
      }
    }

    // DOMì´ ì¤€ë¹„ëœ í›„ì— ìš”ì†Œ ì„ íƒ ë° ì´ë²¤íŠ¸ ë°”ì¸ë”©
    window.addEventListener('DOMContentLoaded', () => {
      connectWsBtn = document.getElementById('connectWs');
      disconnectWsBtn = document.getElementById('disconnectWs');
      wsStatusSpan = document.getElementById('wsStatus');
      wsUrlInput = document.getElementById('wsUrl');
      connectSseBtn = document.getElementById('connectSse');
      disconnectSseBtn = document.getElementById('disconnectSse');
      sseStatusSpan = document.getElementById('sseStatus');
      roomInput = document.getElementById('roomInput');
    
      connectWsBtn.onclick = () => {
        if (ws && ws.readyState === WebSocket.OPEN) return;
        try {
          const targetUrl = buildWsUrl(wsUrlInput.value || '');
          const probeUrl = toHttpsUrl(targetUrl);
          preflightHttps(probeUrl).then((ok) => {
            if (!ok) {
              alert('ëª¨ë°”ì¼ì—ì„œ ì¸ì¦ì„œ ì‹ ë¢°ê°€ í•„ìš”í•©ë‹ˆë‹¤. ì•„ë˜ ë§í¬ë¥¼ ì—´ì–´ ìŠ¹ì¸ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”:\n' + probeUrl);
              window.open(probeUrl, '_blank');
            }
          });
          ws = new WebSocket(targetUrl);
          ws.onopen = () => setWsStatus(true);
          ws.onclose = () => setWsStatus(false);
          ws.onerror = (e) => {
            setWsStatus(false);
            alert('WS ì—°ê²° ì˜¤ë¥˜. ì¸ì¦ì„œ ì‹ ë¢° ë˜ëŠ” ë„¤íŠ¸ì›Œí¬/ë°©í™”ë²½ì„ í™•ì¸í•˜ì„¸ìš”.');
          };
    
          ws.onmessage = async (msg) => {
            try {
              const data = JSON.parse(msg.data);
              ensurePC();
              if (data.type === 'offer') {
                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                if (ws && ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify({ type: 'answer', answer: pc.localDescription }));
                } else {
                  sdpBox.value = JSON.stringify(pc.localDescription);
                }
              }
              if (data.type === 'answer') {
                await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
              }
              if (data.type === 'candidate') {
                try {
                  await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                } catch (err) {
                  console.error('Error adding ICE candidate:', err);
                }
              }
            } catch (e) {
              console.error('WS message handling error:', e);
            }
          };
        } catch (e) {
          alert('WS ì—°ê²° ì‹¤íŒ¨: ' + e.message);
        }
      };
    
      disconnectWsBtn.onclick = () => {
        if (ws) {
          try { ws.close(); } catch {}
          ws = null;
          setWsStatus(false);
        }
      };

      connectSseBtn.onclick = () => {
        if (sse) return;
        try {
          const room = (roomInput.value || 'default').trim();
          const sseUrl = `${location.origin}/signaling/${encodeURIComponent(room)}/sse?cid=${encodeURIComponent(clientId)}`;
          sse = new EventSource(sseUrl);
          sse.onopen = () => setSseStatus(true);
          sse.onerror = () => setSseStatus(false);
          sse.onmessage = async (ev) => {
            try {
              const data = JSON.parse(ev.data);
              ensurePC();
              if (data.type === 'offer') {
                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                await sendHttp(room, { type: 'answer', answer: pc.localDescription });
              }
              if (data.type === 'answer') {
                await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
              }
              if (data.type === 'candidate') {
                try { await pc.addIceCandidate(new RTCIceCandidate(data.candidate)); } catch (err) {}
              }
            } catch (err) {}
          };
        } catch (e) {
          alert('SSE ì—°ê²° ì‹¤íŒ¨: ' + e.message);
        }
      };

      disconnectSseBtn.onclick = () => {
        if (sse) { try { sse.close(); } catch {} sse = null; }
        setSseStatus(false);
      };
    });

    function ensurePC() {
      if (!pc) {
        pc = new RTCPeerConnection(configuration);

        const remoteStream = new MediaStream();
        remoteVideo.srcObject = remoteStream;
        pc.ontrack = (event) => {
          event.streams[0].getTracks().forEach((t) => remoteStream.addTrack(t));
        };

        // ë¡œì»¬ ICE í›„ë³´: ìˆ˜ë™ í…ìŠ¤íŠ¸ + WS ì „ì†¡ ë³‘í–‰
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            // ìˆ˜ë™ êµí™˜ì„ ìœ„í•œ í…ìŠ¤íŠ¸ ëˆ„ì 
            localCandidatesBox.value += JSON.stringify(event.candidate) + '\n';
        // WS ì—°ê²° ì‹œ ìë™ ì „ì†¡
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
        } else if (sse) {
          const room = (roomInput.value || 'default').trim();
          sendHttp(room, { type: 'candidate', candidate: event.candidate });
        }
      }
    };

        pc.oniceconnectionstatechange = () => {
          console.log('ICE state:', pc.iceConnectionState);
        };
      }
    }

    // ì¹´ë©”ë¼ ì‹œì‘
    startBtn.onclick = async () => {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
        ensurePC();
        localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));
      } catch (e) {
        alert('ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨: ' + e.message);
      }
    };

    // Offer ìƒì„±: ìˆ˜ë™/WS ë³‘í–‰
    async function handleCreateOffer() {
      try {
        ensurePC();
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
    
        // í•­ìƒ í…ìŠ¤íŠ¸ ë°•ìŠ¤ì— ì±„ìš°ê¸°
        sdpBox.value = JSON.stringify(pc.localDescription);
    
        // WS ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ ì¶”ê°€ë¡œ ì „ì†¡
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'offer', offer: pc.localDescription }));
        } else if (sse) {
          const room = (roomInput.value || 'default').trim();
          await sendHttp(room, { type: 'offer', offer: pc.localDescription });
        }
      } catch (e) {
        alert('Offer ìƒì„± ì‹¤íŒ¨: ' + e.message);
      }
    };

    // Answer ìƒì„±: ìˆ˜ë™/WS ë³‘í–‰
    createAnswerBtn.onclick = async () => {
      try {
        ensurePC();
        const remoteOffer = JSON.parse(sdpBox.value.trim());
        await pc.setRemoteDescription(new RTCSessionDescription(remoteOffer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
    
        // í•­ìƒ í…ìŠ¤íŠ¸ ë°•ìŠ¤ì— ì±„ìš°ê¸°
        sdpBox.value = JSON.stringify(pc.localDescription);
    
        // WS ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ ì¶”ê°€ë¡œ ì „ì†¡
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'answer', answer: pc.localDescription }));
        } else if (sse) {
          const room = (roomInput.value || 'default').trim();
          await sendHttp(room, { type: 'answer', answer: pc.localDescription });
        }
      } catch (e) {
        alert('Answer ìƒì„± ì‹¤íŒ¨: ' + e.message);
      }
    };

    // Remote Answer ìˆ˜ë™ ì ìš©
    setRemoteAnswerBtn.onclick = async () => {
      try {
        const remoteAnswer = JSON.parse(sdpBox.value.trim());
        await pc.setRemoteDescription(new RTCSessionDescription(remoteAnswer));
        alert('Remote Answer ì ìš© ì™„ë£Œ!');
      } catch (e) {
        alert('Remote Answer ì ìš© ì‹¤íŒ¨: ' + e.message);
      }
    };

    // Remote ICE candidates ìˆ˜ë™ ì ìš©
    addRemoteCandidatesBtn.onclick = async () => {
      try {
        const lines = remoteCandidatesBox.value
          .split('\n')
          .map((l) => l.trim())
          .filter((l) => !!l);

        for (const line of lines) {
          const candidateObj = JSON.parse(line);
          await pc.addIceCandidate(new RTCIceCandidate(candidateObj));
        }
        alert('Remote ICE candidates ì ìš© ì™„ë£Œ!');
      } catch (e) {
        alert('ICE candidates ì ìš© ì‹¤íŒ¨: ' + e.message);
      }
    };
    
    async function sendHttp(room, payload) {
      try {
        const res = await fetch(`${location.origin}/signaling/${encodeURIComponent(room)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ...payload, senderId: clientId }),
          keepalive: true,
        });
        const json = await res.json().catch(() => ({}));
        if (json && typeof json.delivered === 'number') {
          console.log(`HTTP signaling delivered: ${json.delivered} (${payload.type})`);
          if (json.delivered === 0) {
            alert('ìƒëŒ€ê°€ SSEì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë‘ ê¸°ê¸° ëª¨ë‘ Connect SSE í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.');
          }
        }
      } catch (e) {
        console.error('HTTP signaling ì „ì†¡ ì‹¤íŒ¨:', e);
        alert('HTTP signaling ì „ì†¡ ì‹¤íŒ¨: ' + (e && e.message ? e.message : 'unknown error'));
      }
    }
  </script>
</body>
</html>
