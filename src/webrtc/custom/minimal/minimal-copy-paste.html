<!DOCTYPE html>
<html lang="ko">
<head>
  <script src="/src/webrtc/js/common/set-title.js"></script>
  <link rel="stylesheet" href="../../css/main.css">
  <style>
    .status-idle { color: gray; }
    .status-waiting { color: orange; }
    .status-connecting { color: blue; }
    .status-connected { color: green; }
    .status-disconnected { color: red; }
    .status-error { color: red; font-weight: bold; }
  </style>
</head>
<body>
  <h2>minimal-copy-paste</h2>

  <!-- UI/UX ê¸°ë³¸ ìš”ì†Œ -->
  <div>
    <div class="row">
      <div class="col">
        <h3>Local</h3>
        <p class="status">ìƒíƒœ: <span id="localStatus">-</span></p>
        <video id="localVideo" autoplay playsinline muted></video>
      </div>
      <div class="col">
        <h3>Remote</h3>
        <p class="status">ìƒíƒœ: <span id="remoteStatus">-</span></p>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
    </div>

    <div class="row">
      <button id="startCallBtn" onclick="startCall()">í†µí™” ì—°ê²°</button>
      <button id="endCallBtn" onclick="endCall(); disconnectWss();">í†µí™” ì¢…ë£Œ</button>
      <button id="toggleCameraBtn" onclick="toggleCamera()">ì¹´ë©”ë¼ On/Off</button>
      <button id="toggleAudioBtn" onclick="toggleAudio()">ì˜¤ë””ì˜¤ On/Off</button>
    </div>
  </div>

  <!-- WebSocket signaling controls -->
  <div class="panel">
    <h3>Signaling(WebSocket) ì—°ê²°</h3>
    <p class="sub-text">
      - Aì™€ B ëª¨ë‘ í•˜ë‹¨ WS URL ì…ë ¥ë€ì´ wss://localhost:3001ì¸ì§€ í™•ì¸ í›„ â€œConnect WSâ€ í´ë¦­í•˜ì—¬ connected í™•ì¸<br/>
      - disconnectedì¸ ê²½ìš°, <a href="#" onclick="openTab('https://192.168.2.95:3001'); return false;">https://192.168.2.95:3001</a> ì‹œê·¸ë„ë§ ì„œë²„ ì‹ ë¢°ëœ ì‚¬ì´íŠ¸ ì„¤ì •
      - Aì—ì„œ â€œCreate Offerâ€ í´ë¦­<br/>
      - Bì—ì„œ ìë™ìœ¼ë¡œ Answer ì‘ë‹µ, ICE í›„ë³´ ìë™ êµí™˜<br/>
    </p>

    <div class="row">
      <label>
        WS URL:
        <input id="wsUrl" type="text" style="width: 360px;" value="wss://192.168.2.95:3001" />
      </label>
      <button id="connectWs" onclick="connectWss()">ğŸ”Œ Connect WS</button>
      <button id="disconnectWs" onclick="disconnectWss()">âŒ Disconnect WS</button>
      <span id="wsStatus">disconnected</span>
    </div>
    <div class="row">
      <button class="createOffer" onclick="handleCreateOffer()">Create Offer</button>
    </div>
  </div>

  <!-- WebRTC ìˆ˜ë™ ì—°ê²° -->
  <div class="panel">
    <h3>ìˆ˜ë™ WebRTC ì—°ê²°</h3>
    <p class="sub-text">
      - Aì—ì„œ â€œCreate Offerâ€ í´ë¦­ â†’ Aì˜ SDPì— Offer í…ìŠ¤íŠ¸ ìƒì„±<br/>
      - Aì˜ SDP Offer í…ìŠ¤íŠ¸ë¥¼ Bì˜ SDPì— ë¶™ì—¬ë„£ê³  â€œCreate Answerâ€ í´ë¦­ â†’ Bì˜ SDPì— Answer í…ìŠ¤íŠ¸ ìƒì„±<br/>
      - Bì˜ SDP Answer í…ìŠ¤íŠ¸ë¥¼ Aì˜ SDPì— ë¶™ì—¬ë„£ê³  â€œSet Remote Answerâ€ í´ë¦­ â†’ Aì˜ ICE Candidatesì— í…ìŠ¤íŠ¸ ìƒì„±<br/>
      - Aì˜ ICE Candidates í…ìŠ¤íŠ¸ë¥¼ ë³µì‚¬ â†’ Bì˜ Remote ICE Candidatesì— ë¶™ì—¬ë„£ê³  â€œAdd Remote ICE Candidatesâ€ í´ë¦­<br/>
    </p>

    <div class="row">
      <button class="createOffer" onclick="handleCreateOffer()" title="RTCPeerConnectionì„ ë§Œë“¤ê³ , ë‚´ ì—°ê²° ì €ì¥ë¥¼ ë‹´ì€ Offer(SDP)ë¥¼ ìƒì„±í•´ ìƒëŒ€ì—ê²Œ ë³´ë‚´ê¸° ìœ„í•œ ì´ë²¤íŠ¸">Create Offer</button>
      <button id="createAnswer" onclick="handleCreateAnswer()" title="ìƒëŒ€ê°€ ë³´ë‚¸ Offerë¥¼ ë°›ì•„ì„œ, ë‚´ê°€ ì—°ê²°í•  ì¤€ë¹„ê°€ ë˜ì—ˆë‹¤ëŠ” Answer(SDP)ë¥¼ ìƒì„±í•˜ëŠ” ì´ë²¤íŠ¸">Create Answer</button>
      <button id="setRemoteAnswer" onclick="handleSetRemoteAnswer()" title="ìƒëŒ€ê°€ ë³´ë‚¸ Answer(SDP)ë¥¼ ë‚´ RTCPeerConnectionì— ì ìš©í•˜ëŠ” ì´ë²¤íŠ¸">Set Remote Answer</button>
      <button id="addRemoteCandidates" onclick="handleAddRemoteCandidates()">Add Remote ICE Candidates</button>
    </div>

    <div class="row">
      <div class="col">
        <h4>SDP (Offer/Answer)</h4>
        <textarea id="sdpBox"></textarea>
      </div>
      <div class="col">
        <h4>ICE Candidates</h4>
        <textarea id="localCandidatesBox"></textarea>
      </div>
      <div class="col">
        <h4>Remote ICE Candidates</h4>
        <textarea id="remoteCandidatesBox"></textarea>
      </div>
    </div>
  </div>

  <script>
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const localStatus = document.getElementById('localStatus');
    const remoteStatus = document.getElementById('remoteStatus');

    const startCallBtn = document.getElementById('startCallBtn');
    const endCallBtn = document.getElementById('endCallBtn');
    const toggleCameraBtn = document.getElementById('toggleCameraBtn');
    const toggleAudioBtn = document.getElementById('toggleAudioBtn');

    const connectWsBtn = document.getElementById('connectWs');
    const disconnectWsBtn = document.getElementById('disconnectWs');

    const createOfferBtns = document.querySelectorAll('.createOffer');
    const createAnswerBtn = document.getElementById('createAnswer');
    const setRemoteAnswerBtn = document.getElementById('setRemoteAnswer');
    const addRemoteCandidatesBtn = document.getElementById('addRemoteCandidates');

    const sdpBox = document.getElementById('sdpBox');
    const localCandidatesBox = document.getElementById('localCandidatesBox');
    const remoteCandidatesBox = document.getElementById('remoteCandidatesBox');

    const configuration = {
      iceServers: []
    };

    let pc;
    let localStream;
    let ws = null;

    /**
     * socket ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
     */
    function setWsStatus(connected) {
      const wsStatusSpan = document.getElementById('wsStatus');
      wsStatusSpan.textContent = connected ? 'connected' : 'disconnected';
      wsStatusSpan.style.color = connected ? 'green' : 'red';
    }

    /**
     * í†µí™” ì—°ê²° ìƒíƒœ í•¨ìˆ˜
     */
    function setCallStatus(who, status, message) {
      const statusSpan = who === 'local' ? localStatus : remoteStatus;
      const statusMap = {
        IDLE: { text: 'ëŒ€ê¸°ì¤‘', className: 'status-idle' },
        WAITING: { text: 'ì ‘ì†', className: 'status-waiting' },
        CONNECTING: { text: 'ì—°ê²° ì‹œë„ ì¤‘', className: 'status-connecting' },
        CONNECTED: { text: 'í†µí™” ì¤‘', className: 'status-connected' },
        DISCONNECTED: { text: 'í†µí™” ì¢…ë£Œ', className: 'status-disconnected' },
        error: { text: 'ì˜¤ë¥˜', className: 'status-error' },
      };
      const { text, className } = statusMap[status] || { text: message || status, className: '' };
      statusSpan.textContent = text + (message ? ` (${message})` : '');
      statusSpan.className = className;

      // ìƒíƒœë¥¼ ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡
      if (who === 'local' && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'status', status }));
      }
    }

    /**
     * WebRTC ë²„íŠ¼ ê´€ë ¨ ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
     * @param {boolean} disable - trueì´ë©´ "Start Camera"ë¥¼ ì œì™¸í•œ ëª¨ë“  ë²„íŠ¼ì„ ë¹„í™œì„±í™”,
     *                            falseì´ë©´ ì¹´ë©”ë¼ê°€ ì¼œì§€ë©´ ëª¨ë“  ë²„íŠ¼ì„ í™œì„±í™”
     */
    function setButtonsDisabled(disabled) {
      connectWsBtn.disabled = disabled;
      disconnectWsBtn.disabled = disabled;
      createAnswerBtn.disabled = disabled;
      setRemoteAnswerBtn.disabled = disabled;
      addRemoteCandidatesBtn.disabled = disabled;
      if (createOfferBtns) {
        createOfferBtns.forEach(btn => btn.disabled = disabled);
      }
    }

    /**
     * ì¹´ë©”ë¼/ì˜¤ë””ì˜¤ ë²„íŠ¼ ê´€ë ¨ ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
     */
    function updateCallButtons(inCall) {
      startCallBtn.disabled = inCall;
      endCallBtn.disabled = !inCall;
      toggleCameraBtn.disabled = !inCall;
      toggleAudioBtn.disabled = !inCall;
    }

    /**
     * RTCPeerConnectionì´ ì—†ìœ¼ë©´ ìƒì„±í•˜ê³ , ì›ê²© ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ì™€ ICE í›„ë³´ ìˆ˜ì§‘/ì „ì†¡ì„ ì„¤ì •í•˜ëŠ” í•¨ìˆ˜
     */
    function ensurePC() {
      if (!pc) {
        pc = new RTCPeerConnection(configuration);

        const remoteStream = new MediaStream();
        remoteVideo.srcObject = remoteStream;
        pc.ontrack = (event) => {
          event.streams[0].getTracks().forEach((t) => remoteStream.addTrack(t));
        };

        // ë¡œì»¬ ICE í›„ë³´: ìˆ˜ë™ í…ìŠ¤íŠ¸ + WS ì „ì†¡ ë³‘í–‰
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            // ìˆ˜ë™ êµí™˜ì„ ìœ„í•œ í…ìŠ¤íŠ¸ ëˆ„ì 
            localCandidatesBox.value += JSON.stringify(event.candidate) + '\n';
            // WS ì—°ê²° ì‹œ ìë™ ì „ì†¡
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
            }
          }
        };

        pc.oniceconnectionstatechange = () => {
          console.log('ICE state:', pc.iceConnectionState);
          switch (pc.iceConnectionState) {
            case 'checking':
              setCallStatus('remote', 'CONNECTING');
              break;
            case 'connected':
            case 'completed':
              setCallStatus('local', 'CONNECTED');
              setCallStatus('remote', 'CONNECTED');
              break;
            case 'failed':
              setCallStatus('remote', 'error', 'ì—°ê²° ì‹¤íŒ¨');
              break;
            case 'disconnected':
            case 'closed':
              setCallStatus('remote', 'DISCONNECTED');
              endCall(); // ìƒëŒ€ë°© ì—°ê²°ì´ ëŠì–´ì§€ë©´ ë‚´ í†µí™”ë„ ì¢…ë£Œ
              break;
          }
        };
      }
    }

    /**
     * WebSocket ì„œë²„ URL ìƒì„± í•¨ìˆ˜ (í•­ìƒ wss ì‚¬ìš©)
     */
    function buildWssUrl(raw) {
      console.log(raw)

      const input = (raw || '').trim();
      const pageIsHttps = location.protocol === 'https:';
      const defaultHostname = location.hostname;
      const defaultPort = 3001;

      if (!input) {
        return `wss://${defaultHostname}:${defaultPort}`;
      }

      return input;
    }

    /**
     * WebSocket ì—°ê²°
     */
    function connectWss() {
      if (ws && ws.readyState === WebSocket.OPEN) return;

      try {
        const wsUrlInput = document.getElementById('wsUrl');
        const targetUrl = buildWssUrl(wsUrlInput.value || '');

        ws = new WebSocket(targetUrl);
        ws.onopen = () => setWsStatus(true);
        ws.onclose = () => setWsStatus(false);

        ws.onerror = (e) => {
          setWsStatus(false);
          alert('WS ì—°ê²° ì˜¤ë¥˜. ì¸ì¦ì„œ ì‹ ë¢° ë˜ëŠ” ë„¤íŠ¸ì›Œí¬/ë°©í™”ë²½ì„ í™•ì¸í•˜ì„¸ìš”.');
        };
  
        ws.onmessage = async (msg) => {
          try {
            const data = JSON.parse(msg.data);
            ensurePC();

            if (data.type === 'offer') {
              setCallStatus('remote', 'CONNECTING');
              await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'answer', answer: pc.localDescription }));
              } else {
                sdpBox.value = JSON.stringify(pc.localDescription);
              }
            }

            if (data.type === 'answer') {
              await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
            }

            if (data.type === 'candidate') {
              try {
                await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
              } catch (err) {
                console.error('Error adding ICE candidate:', err);
              }
            }

            if (data.type === 'status') {
              setCallStatus('remote', data.status);
            }
          } catch (e) {
            console.error('WS message handling error:', e);
          }
        };
      } catch (e) {
        alert('WS ì—°ê²° ì‹¤íŒ¨: ' + e.message);
      }
    }

    /**
     * WebSocket ì—°ê²° ì¢…ë£Œ
     */
    function disconnectWss() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        // ì¢…ë£Œ ìƒíƒœ ì „ì†¡
        ws.send(JSON.stringify({ type: 'status', status: 'DISCONNECTED' }));
      }

      if (ws) {
        try { ws.close(); } catch {}
        ws = null;
        setWsStatus(false);
      }
      endCall()
    }
  
    /**
     * í†µí™” ì—°ê²°
     */
    async function startCall() {
      try {
        // ê¶Œí•œ í™•ì¸
        const cameraStatus = await navigator.permissions.query({ name: 'camera' });
        const microphoneStatus = await navigator.permissions.query({ name: 'microphone' });
        if (cameraStatus.state === 'denied') { alert('ì¹´ë©”ë¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.'); return; }
        if (microphoneStatus.state === 'denied') { alert('ë§ˆì´í¬ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.'); return; }

        // ë¯¸ë””ì–´ ì¥ì¹˜ ì—°ê²°
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;

        // WebRTC ì—°ê²°
        ensurePC();
        localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));

        // UX ìƒíƒœ ì—…ë°ì´íŠ¸
        setButtonsDisabled(false);
        updateCallButtons(true);
        setCallStatus('local', 'WAITING');
        setCallStatus('remote', 'IDLE');
      } catch (e) {
        setCallStatus('local', 'error', e.message);
        alert('Error startCamera\n' + e.message);
      }
    }
    
    /**
     * í†µí™” ì¢…ë£Œ
     */
    function endCall() {
      if (pc) {
        pc.close();
        pc = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      setCallStatus('local', 'DISCONNECTED');
      setCallStatus('remote', 'DISCONNECTED'); 

      // UI ì´ˆê¸°í™”
      sdpBox.value = '';
      localCandidatesBox.value = '';
      remoteCandidatesBox.value = '';
      setButtonsDisabled(true);
      updateCallButtons(false);
    }

    /**
     * ì¹´ë©”ë¼ On/Off
     */
    function toggleCamera() {
      if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          videoTrack.enabled = !videoTrack.enabled;
        }
      }
    }

    /**
     * ì˜¤ë””ì˜¤ On/Off
     */
    function toggleAudio() {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
        }
      }
    }

    
    // Offer ìƒì„±: ìˆ˜ë™/WS ë³‘í–‰
    async function handleCreateOffer() {
      try {
        ensurePC();
        setCallStatus('local', 'CONNECTING');
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
    
        // í•­ìƒ í…ìŠ¤íŠ¸ ë°•ìŠ¤ì— ì±„ìš°ê¸°
        sdpBox.value = JSON.stringify(pc.localDescription);
    
        // WS ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ ì¶”ê°€ë¡œ ì „ì†¡
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'offer', offer: pc.localDescription }));
        }
      } catch (e) {
        alert('Offer ìƒì„± ì‹¤íŒ¨: ' + e.message);
      }
    };

    // Answer ìƒì„±: ìˆ˜ë™/WS ë³‘í–‰
    async function handleCreateAnswer() {
      try {
        ensurePC();
        const remoteOffer = JSON.parse(sdpBox.value.trim());
        await pc.setRemoteDescription(new RTCSessionDescription(remoteOffer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
    
        // í•­ìƒ í…ìŠ¤íŠ¸ ë°•ìŠ¤ì— ì±„ìš°ê¸°
        sdpBox.value = JSON.stringify(pc.localDescription);
    
        // WS ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ ì¶”ê°€ë¡œ ì „ì†¡
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'answer', answer: pc.localDescription }));
        }
      } catch (e) {
        alert('Answer ìƒì„± ì‹¤íŒ¨: ' + e.message);
      }
    }

    // Remote Answer ìˆ˜ë™ ì ìš©
    async function handleSetRemoteAnswer() {
      try {
        const remoteAnswer = JSON.parse(sdpBox.value.trim());
        await pc.setRemoteDescription(new RTCSessionDescription(remoteAnswer));
        alert('Remote Answer ì ìš© ì™„ë£Œ!');
      } catch (e) {
        alert('Remote Answer ì ìš© ì‹¤íŒ¨: ' + e.message);
      }
    }

    // Remote ICE candidates ìˆ˜ë™ ì ìš©
    async function handleAddRemoteCandidates() {
      try {
        const lines = remoteCandidatesBox.value
          .split('\n')
          .map((l) => l.trim())
          .filter((l) => !!l);

        for (const line of lines) {
          const candidateObj = JSON.parse(line);
          await pc.addIceCandidate(new RTCIceCandidate(candidateObj));
        }
        alert('Remote ICE candidates ì ìš© ì™„ë£Œ!');
      } catch (e) {
        alert('ICE candidates ì ìš© ì‹¤íŒ¨: ' + e.message);
      }
    }
  
    // ìƒˆ íƒ­ ì—´ê¸°
    function openTab(url) {
      window.open(url, '_blank');
    }
    
    window.addEventListener('DOMContentLoaded', () => {
      // UX ìƒíƒœ ì—…ë°ì´íŠ¸
      setButtonsDisabled(true);
      updateCallButtons(false);
      setCallStatus('local', 'IDLE');
      setCallStatus('remote', 'IDLE');
    });
  </script>
</body>
</html>
