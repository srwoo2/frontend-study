<!DOCTYPE html>
<html lang="ko">
<head>
  <script src="/src/webrtc/js/common/set-title.js"></script>
  <script src="/src/webrtc/js/common/utils.js"></script>
  <script src="/src/webrtc/js/common/CallManager.js"></script>
  <script src="/src/webrtc/js/common/SignalingService.js"></script>
  <link rel="stylesheet" href="/src/webrtc/css/main.css">
</head>
<body>
  <div id='container'>
    <div style="position: absolute; top: 10px; right: 10px; z-index: 100;">
      <button 
        id="approveCertBtn" 
        class="btn-small" 
        onclick="window.open(CONFIG.wssCertUrl, '', 'width=800,height=600')">
        인증서 허용(wss)
      </button>
    </div>

    <div class="status-pill">
      <div><span id="statusText">WAITING</span></div>
      <div style="margin-left: 10px; padding-left: 10px; border-left: 1px solid #555;">WS: <span id="wsStatusText" style="color: red;">disconnected</span></div>
    </div>
  
    <div class="split-container">
      <div class="video-box">
        <div class="label">상대방 (Remote)</div>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
      <div class="video-box">
        <div class="label">나 (Local)</div>
        <video id="localVideo" autoplay playsinline></video>
      </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay">
      <div class="spinner"></div>
      <div class="loading-text">연결 중...</div>
    </div>
  
    <div class="control-bar">
      <button id="startCallBtn" class="btn-primary" onclick="startCall()" style="display:none">통화 시작</button>
      <button id="endCallBtn" class="btn-danger" onclick="endCall()" style="display:none">통화 종료</button>
      <button id="toggleCameraBtn" class="btn-secondary" onclick="callManager.toggleMedia('video')" style="display:none">카메라 On</button>
      <button id="toggleAudioBtn" class="btn-secondary" onclick="callManager.toggleMedia('audio')" style="display:none">마이크 On</button>
      <button id="retryBtn" class="btn-primary" onclick="init()" style="display:none">다시 연결</button>
    </div>
  </div>

  <script>
    const CONFIG = {
      wssUrl: `wss://${window.location.hostname}:3001`,
      wssCertUrl: `https://${window.location.hostname}:3001`,
      iceServers: { iceServers: [] },
      connectTimeoutMs: 10000
    };

    const ui = {
      status: document.getElementById('statusText'),
      wsStatus: document.getElementById('wsStatusText'),
      overlay: document.getElementById('loadingOverlay'),
      btns: {
        start: document.getElementById('startCallBtn'),
        end: document.getElementById('endCallBtn'),
        camera: document.getElementById('toggleCameraBtn'),
        audio: document.getElementById('toggleAudioBtn'),
        retry: document.getElementById('retryBtn')
      }
    };

    // 1. Signaling 초기화
    const signaling = new WebSocketSignaling(
      CONFIG.wssUrl,
      () => { ui.wsStatus.textContent = 'connected'; ui.wsStatus.style.color = 'white'; },
      (e) => { 
        ui.wsStatus.textContent = 'disconnected'; ui.wsStatus.style.color = 'red';
        if (event.code !== 1000 && (callManager.state === CALL_STATUS.CONNECTED.id || callManager.state === CALL_STATUS.CONNECTING.id)) {
           alert(ERRORS.DISCONNECTED_BY_SERVER);
        }
      },
      (e) => console.error("WS Error", e)
    );

    // 2. CallManager 초기화
    const callManager = new CallManager(
      CONFIG,
      (state) => updateUi(state),
      (candidate) => signaling.send({ type: 'candidate', candidate })
    );

    // Signaling 메시지 핸들러
    signaling.onMessage = async (data) => {
      switch (data.type) {
        case 'offer':
          const answer = await callManager.handleOffer(data.offer);
          signaling.send({ type: 'answer', answer });
          break;
        case 'answer':
          await callManager.handleAnswer(data.answer);
          break;
        case 'candidate':
          await callManager.addIceCandidate(data.candidate);
          break;
        case 'leave':
          alert(ERRORS.PEER_LEFT);
          endCall();
          break;
      }
    };

    function updateUi(state) {
      ui.status.textContent = CALL_STATUS[state].label;
      Object.values(ui.btns).forEach(b => b.style.display = 'none');
      ui.overlay.style.display = (state === CALL_STATUS.CONNECTING.id) ? 'flex' : 'none';

      if (state === CALL_STATUS.IDLE.id) {
        ['start', 'audio', 'camera'].forEach(k => ui.btns[k].style.display = 'block');
      } else if (state === CALL_STATUS.CONNECTING.id || state === CALL_STATUS.CONNECTED.id) {
        ['end', 'audio', 'camera'].forEach(k => ui.btns[k].style.display = 'block');
      } else if (state === CALL_STATUS.ERROR.id) {
        ui.btns.retry.style.display = 'block';
      }
    }

    async function startCall() {
      try {
        callManager.state = CALL_STATUS.CONNECTING.id;
        callManager.ensurePC(document.getElementById('remoteVideo'));
        await signaling.connect();
        const offer = await callManager.createOffer();
        signaling.send({ type: 'offer', offer });
      } catch (e) {
        handleError(e, startCall);
      }
    }

    function endCall() {
      signaling.send({ type: 'leave' });
      signaling.close();
      callManager.closePC();
      callManager.stopMedia();
      document.getElementById('localVideo').srcObject = null;
      callManager.state = CALL_STATUS.DISCONNECTED.id;
    }

    async function init() {
      try {
        await callManager.getMediaStream(document.getElementById('localVideo'));
        callManager.state = CALL_STATUS.IDLE.id;
      } catch (e) {
        handleError(e, init);
      }
    }

    window.onload = init;
    window.onbeforeunload = endCall;
  </script>
</body>
</html>