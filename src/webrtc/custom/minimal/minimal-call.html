<!DOCTYPE html>
<html lang="ko">
<head>
  <script src="/src/webrtc/js/common/set-title.js"></script>
  <script src="/src/webrtc/js/common/utils.js"></script>
  <link rel="stylesheet" href="../../css/minimal.css">
</head>
<body>
  <div class='container'>
    <div class="status-pill">
      <span id="statusText">IDLE</span>
    </div>
  
    <div class="split-container">
      <div class="video-box">
        <div class="label">상대방 (Remote)</div>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
      <div class="video-box">
        <div class="label">나 (Local)</div>
        <video id="localVideo" autoplay playsinline muted></video>
      </div>
    </div>
  
    <div class="control-bar">
      <button id="startCallBtn" class="btn-primary" onclick="startCall()" style="display:none">통화 시작</button>
      <button id="endCallBtn" class="btn-danger" onclick="endCall()" style="display:none">통화 종료</button>
      <button id="toggleCameraBtn" class="btn-secondary" onclick="toggleCamera()" style="display:none">카메라 On</button>
      <button id="toggleAudioBtn" class="btn-secondary" onclick="toggleAudio()" style="display:none">마이크 On</button>
      <button id="retryBtn" class="btn-primary" onclick="enterWaitingState()" style="display:none">다시 연결</button>
    </div>
  </div>

  <script>
    const elStatusText = document.getElementById('statusText');

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');

    const startCallBtn = document.getElementById('startCallBtn');
    const endCallBtn = document.getElementById('endCallBtn');
    const toggleCameraBtn = document.getElementById('toggleCameraBtn');
    const toggleAudioBtn = document.getElementById('toggleAudioBtn');
    const retryBtn = document.getElementById('retryBtn');

    const CONFIG = {
      wssUrl: 'wss://192.168.2.95:3001',
      logUrl: 'https://192.168.2.95:3000/log',
      iceServers: { iceServers: [] },
      connectTimeoutMs: 10000
    };

    let pc = null;
    let localStream = null;
    let ws = null;
    let _ws_state = WS_STATUS.IDLE.id;
    Object.defineProperty(window, 'ws_state', {
      get: function() { return _ws_state; },
      set: function(val) {
        _ws_state = val;
        updateUiForState();
      }
    });

    /**
     * 연결 상태 UI 표시
     */
    function updateUiForState() {
      const stateId = WS_STATUS[ws_state].id || '';
      elStatusText.textContent = WS_STATUS[ws_state].label || '';

      startCallBtn.style.display = 'none';
      retryBtn.style.display = 'none';
      endCallBtn.style.display = 'none';
      toggleAudioBtn.style.display = 'none';
      toggleCameraBtn.style.display = 'none';

      switch (stateId) {
        case WS_STATUS.IDLE.id:
          break;
        case WS_STATUS.WAITING.id:
          startCallBtn.textContent = '통화 시작';
          startCallBtn.style.display = 'flex';
          toggleAudioBtn.style.display = 'flex';
          toggleCameraBtn.style.display = 'flex';
          break;
        case WS_STATUS.CONNECTING.id:
        case WS_STATUS.CONNECTED.id:
          endCallBtn.style.display = 'flex';
          toggleAudioBtn.style.display = 'flex';
          toggleCameraBtn.style.display = 'flex';
          break;
        case WS_STATUS.ERROR.id:
          retryBtn.style.display = 'flex';
          break;
        case WS_STATUS.DISCONNECTED.id:
        default:
          break;
      }
    }

    /**
     * RTCPeerConnection(PC) 생성
     */
    function ensurePC() {
      if (pc) return;
      
      pc = new RTCPeerConnection(CONFIG.iceServers);
      
      localStream.getTracks().forEach(track => {
        if (!pc.getSenders().find(s => s.track === track)) {
          pc.addTrack(track, localStream);
        }
      });

      const remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;

      /**
       * 상대방이 보낸 audio/video track 수신 핸들러
       * WebRTC는 track 단위로 데이터를 전송하므로
       * 수신된 track을 remoteStream에 추가 → 화면에 표시됨
       */
      pc.ontrack = (event) => {
        console.log('ontrack', event);
        const stream = event.streams?.[0];

        if (stream) {
          stream.getTracks().forEach((t) => remoteStream.addTrack(t));
        } else {
          remoteStream.addTrack(event.track);
        }

        event.track.onmute = () => {
          console.warn("Remote track muted → 수신 중단");
          ws_state = WS_STATUS.DISCONNECTED.id;
        };

        event.track.onended = () => {
          console.log('Remote track ended');
          ws_state = WS_STATUS.DISCONNECTED.id;
        };
      };

      /**
       * ICE 후보(candidates)가 생성될 때마다 호출되는 핸들러
       * 연결 상대에게 candidate 정보를 WebSocket으로 전송하여
       * NAT Traversal(방화벽 통과)을 가능하게 함
       */
      pc.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
        }
      };

      /**
       * ICE 연결 상태 변화 핸들러
       */
      pc.oniceconnectionstatechange = () => {
        console.log('ICE state:', pc.iceConnectionState);

        switch (pc.iceConnectionState) {
          case 'checking': // P2P 연결 시도 중
            ws_state = WS_STATUS.CONNECTING.id;
            break;
          case 'connected': // P2P 연결 완료
            ws_state = WS_STATUS.CONNECTED.id;
            break;
          case 'failed': // 연결 실패
          case 'disconnected': // 연결 종료
          case 'closed': // 연결 종료
            endCall();
            break;
        }
      };
    }

    /**
     * 시그널링 서버 연결
     */
    async function connectWss() {
      return new Promise((resolve, reject) => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          return resolve();
        }

        if (ws && ws.readyState === WebSocket.CONNECTING) {
          ws.addEventListener('open', () => resolve());
          ws.addEventListener('error', (err) => reject(err));
          return;
        }

        try {
          ws = new WebSocket(CONFIG.wssUrl);
          
          ws.onopen = () => {
            console.log('WebSocket connected');
            resolve();
          };
          ws.onclose = () => {
            console.log('WebSocket disconnected');
            ws = null; 
          };
          ws.onerror = (e) => {
            console.log('WebSocket error');
            handleError(e, startCall);
            reject(e);
          };
          ws.onmessage = async (msg) => {
            try {
              const data = JSON.parse(msg.data);

              switch(data.type) {
                case 'offer': {
                  await pc.setRemoteDescription(new RTCSessionDescription(data.offer));

                  const answer = await pc.createAnswer();
                  await pc.setLocalDescription(answer);

                  if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'answer', answer: pc.localDescription }));
                  }
                  break;
                }
                case 'answer': {
                  await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                  break;
                }
                case 'candidate': {
                  await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                  break;
                }
              }
            } catch (e) {
              console.error('WS message handling error:', e);
            }
          };
        } catch (e) {
          console.error('WS 연결 실패: ' + e.message);
          reject(e);
        }
      });
    }
    
    /**
     * 카메라/마이크 권한 요청
     */
    async function checkMediaPermissions() {
      const cameraStatus = await navigator.permissions.query({ name: 'camera' });
      const microphoneStatus = await navigator.permissions.query({ name: 'microphone' });

      if (cameraStatus.state === 'denied') {
        throw new Error('카메라 권한을 확인해 주세요.');
      }
      if (microphoneStatus.state === 'denied') {
        throw new Error('마이크 권한을 확인해 주세요.');
      }
    }

    /**
     * 미디어 장치 연결
     */
    async function getMediaStream() {
      if (localStream) return;

      const devices = await navigator.mediaDevices.enumerateDevices();

      const hasCamera = devices.some(d => d.kind === 'videoinput');
      const hasMic = devices.some(d => d.kind === 'audioinput');

      if (!hasCamera) {
        throw new Error('연결된 카메라가 없습니다.');
      }
      if (!hasMic) {
        throw new Error('연결된 마이크가 없습니다.');
      }

      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      localStream = stream;
      localVideo.srcObject = stream;
    }

    /**
     * 대기 상태 진입
     */
    async function enterWaitingState() {
      try {
        await checkMediaPermissions();
        await getMediaStream();

        ws_state = WS_STATUS.WAITING.id;
      } catch (e) {
        handleError(e, enterWaitingState);
      }
    }

    /**
     * 통화 연결 요청
     */
    async function startCall() {
      try {
        // pc 연결
        ensurePC();

        // 소켓 연결
        await connectWss();

        // offer 생성
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'offer', offer: pc.localDescription }));
        }
      } catch (e) {
        handleError(e, startCall);
      }
    }
    
    /**
     * 통화 종료 요청
     */
    function endCall() {
      try {
        // pc 해제
        if (pc) {
          pc.close();
          pc = null;
        }

        // 로컬 미디어 해제
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
        }
        localVideo.srcObject = null;

        // 소켓 해제
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.close();
        }
      } catch (e) {
        handleError(e);
      }
    }

    function toggleCamera() {
      if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          videoTrack.enabled = !videoTrack.enabled;
          toggleCameraBtn.textContent = `카메라 ${videoTrack.enabled ? 'On' : 'Off'}`;
        }
      }
    }

    function toggleAudio() {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          toggleAudioBtn.textContent = `오디오 ${audioTrack.enabled ? 'On' : 'Off'}`;
        }
      }
    }

    /**
     * 공통 에러 핸들러
     * @param {Error} e 에러 객체
     * @param {Function} retryAction 재시도 시 실행할 함수 (옵션)
     */
    function handleError(e, retryAction) {
      ws_state = WS_STATUS.ERROR.id;

      const msg = e.message || e;
      alert(msg);
      log('ERROR', msg);

      if (retryAction && typeof retryAction === 'function') {
        retryBtn.onclick = async () => {
          try {
            await retryAction();
          } catch (err) {
            handleError(err, retryAction);
          }
        };
      } else {
        retryBtn.onclick = enterWaitingState; 
      }
    }

    window.onload = () => {
      updateUiForState();
      enterWaitingState();
    };
    window.onbeforeunload = () => {
      endCall();
    };
    window.onerror = (msg, url, line) => log('ERROR', `Global: ${msg} (${line})`);
  </script>
</body>
</html>