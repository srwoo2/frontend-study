<!DOCTYPE html>
<html lang="ko">
<head>
  <script src="/src/webrtc/js/common/set-title.js"></script>
  <script src="/src/webrtc/js/common/utils.js"></script>
</head>
  <style>
    :root {
      --bg-color: #202124;
      --text: #ffffff;
    }
  </style>
</head>
<body>
  <div id="container">
    <div class="status-pill">
      <div>Local: <span id="localStatus">IDLE</span></div>
      <div style="margin-left: 10px; padding-left: 10px; border-left: 1px solid #555;">Remote: <span id="remoteStatus">IDLE</span></div>
      <div style="margin-left: 10px; padding-left: 10px; border-left: 1px solid #555;">WS: <span id="wsStatus" style="color: red;">disconnected</span></div>
    </div>

    <div class="split-container">
      <div class="video-box">
        <div class="label">상대방 (Remote)</div>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
      <div class="video-box">
        <div class="label">나 (Local)</div>
        <video id="localVideo" autoplay playsinline muted></video>
      </div>
    </div>

    <div class="control-bar">
      <button id="startCallBtn" class="btn-primary" onclick="startCall()">통화 연결</button>
      <button id="endCallBtn" class="btn-danger" onclick="endCall(); disconnectWss();" disabled>통화 종료</button>
      <button id="toggleCameraBtn" class="btn-secondary" onclick="toggleCamera()" disabled>카메라</button>
      <button id="toggleAudioBtn" class="btn-secondary" onclick="toggleAudio()" disabled>마이크</button>
      <button id="connectWs" class="btn-secondary" onclick="connectWss()" disabled>Connect WS</button>
      <button id="createOfferBtn" class="btn-secondary createOffer" onclick="handleCreateOffer()" disabled>Create Offer</button>
      <button class="btn-secondary" onclick="document.getElementById('wsPanel').style.display = 'block'">WS 설정</button>
    </div>

    <div id="wsPanel" class="panel" style="display: none; position: absolute; top: 20%; left: 20%; width: 60%; background: rgba(32, 33, 36, 0.95); z-index: 100; border: 1px solid #444; color: #fff; padding: 20px;">
      <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #444; margin-bottom: 15px; padding-bottom: 10px;">
        <h3 style="margin: 0;">Signaling 설정</h3>
        <button class="btn-secondary" style="height: 32px; padding: 0 16px;" onclick="document.getElementById('wsPanel').style.display = 'none'">닫기</button>
      </div>
      <div class="row" style="margin-bottom: 15px; align-items: center;">
        <label style="margin-right: 10px;">WS URL:</label>
        <input id="wsUrl" type="text" style="flex: 1; height: 40px; background: #111; color: #fff; border: 1px solid #555; padding: 0 10px;" value="wss://192.168.2.95:3001" />
      </div>
      <p class="sub-text" style="color: #aaa;">
        - A와 B 모두 하단 WS URL 입력란이 wss://localhost:3001인지 확인 후 “Connect WS” 클릭하여 connected 확인<br/>
        - disconnected인 경우, <a href="#" style="color: #8ab4f8;" onclick="openTab('https://192.168.2.95:3001'); return false;">인증서 신뢰 설정</a> 필요
      </p>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">연결 중...</div>
  </div>

  <script>
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const localStatus = document.getElementById('localStatus');
    const remoteStatus = document.getElementById('remoteStatus');

    const startCallBtn = document.getElementById('startCallBtn');
    const endCallBtn = document.getElementById('endCallBtn');
    const toggleCameraBtn = document.getElementById('toggleCameraBtn');
    const toggleAudioBtn = document.getElementById('toggleAudioBtn');

    const connectWsBtn = document.getElementById('connectWs');
    const createOfferBtns = document.querySelectorAll('.createOffer');

    const configuration = { iceServers: [] };

    let pc;
    let localStream;
    let ws = null;

    /**
     * socket 연결 상태 업데이트 함수
     */
    function setWsStatus(connected) {
      const wsStatusSpan = document.getElementById('wsStatus');
      wsStatusSpan.textContent = connected ? 'connected' : 'disconnected';
      wsStatusSpan.style.color = connected ? 'green' : 'red';
    }

    /**
     * 통화 연결 상태 함수
     */
    function setCallStatus(who, status, message) {
      const statusSpan = who === 'local' ? localStatus : remoteStatus;
      const statusMap = {
        IDLE: { text: '대기중', className: 'status-idle' },
        WAITING: { text: '접속', className: 'status-waiting' },
        CONNECTING: { text: '연결 시도 중', className: 'status-connecting' },
        CONNECTED: { text: '통화 중', className: 'status-connected' },
        DISCONNECTED: { text: '통화 종료', className: 'status-disconnected' },
        error: { text: '오류', className: 'status-error' },
      };
      const { text, className } = statusMap[status] || { text: message || status, className: '' };
      statusSpan.textContent = text + (message ? ` (${message})` : '');
      statusSpan.className = className;

      // 상태를 상대방에게 전송
      if (who === 'local' && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'status', status }));
      }
    }

    /**
     * WebRTC 버튼 관련 상태 업데이트 함수
     * @param {boolean} disable - true이면 "Start Camera"를 제외한 모든 버튼을 비활성화,
     *                            false이면 카메라가 켜지면 모든 버튼을 활성화
     */
    function setButtonsDisabled(disabled) {
      connectWsBtn.disabled = disabled;
      if (createOfferBtns) {
        createOfferBtns.forEach(btn => btn.disabled = disabled);
      }
    }

    /**
     * 카메라/오디오 버튼 관련 상태 업데이트 함수
     */
    function updateCallButtons(inCall) {
      startCallBtn.disabled = inCall;
      endCallBtn.disabled = !inCall;
      toggleCameraBtn.disabled = !inCall;
      toggleAudioBtn.disabled = !inCall;
    }

    /**
     * RTCPeerConnection이 없으면 생성하고, 원격 스트림 처리와 ICE 후보 수집/전송을 설정하는 함수
     */
    function ensurePC() {
      if (!pc) {
        pc = new RTCPeerConnection(configuration);

        const remoteStream = new MediaStream();
        remoteVideo.srcObject = remoteStream;
        pc.ontrack = (event) => {
          event.streams[0].getTracks().forEach((t) => remoteStream.addTrack(t));
        };

        // 로컬 ICE 후보: 수동 텍스트 + WS 전송 병행
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            // WS 연결 시 자동 전송
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
            }
          }
        };

        pc.oniceconnectionstatechange = () => {
          console.log('ICE state:', pc.iceConnectionState);
          switch (pc.iceConnectionState) {
            case 'checking':
              setCallStatus('remote', 'CONNECTING');
              break;
            case 'connected':
            case 'completed':
              setCallStatus('local', 'CONNECTED');
              setCallStatus('remote', 'CONNECTED');
              document.getElementById('loadingOverlay').style.display = 'none';
              break;
            case 'failed':
              setCallStatus('remote', 'error', '연결 실패');
              document.getElementById('loadingOverlay').style.display = 'none';
              break;
            case 'disconnected':
            case 'closed':
              setCallStatus('remote', 'DISCONNECTED');
              endCall(); // 상대방 연결이 끊어지면 내 통화도 종료
              break;
          }
        };
      }
    }

    /**
     * WebSocket 서버 URL 생성 함수 (항상 wss 사용)
     */
    function buildWssUrl(raw) {
      console.log(raw)

      const input = (raw || '').trim();
      const pageIsHttps = location.protocol === 'https:';
      const defaultHostname = location.hostname;
      const defaultPort = 3001;

      if (!input) {
        return `wss://${defaultHostname}:${defaultPort}`;
      }

      return input;
    }

    /**
     * WebSocket 연결
     */
    function connectWss() {
      if (ws && ws.readyState === WebSocket.OPEN) return;

      try {
        const wsUrlInput = document.getElementById('wsUrl');
        const targetUrl = buildWssUrl(wsUrlInput.value || '');

        ws = new WebSocket(targetUrl);
        ws.onopen = () => setWsStatus(true);
        ws.onclose = () => setWsStatus(false);

        ws.onerror = (e) => {
          setWsStatus(false);
          alert('WS 연결 오류. 인증서 신뢰 또는 네트워크/방화벽을 확인하세요.');
        };
  
        ws.onmessage = async (msg) => {
          try {
            const data = JSON.parse(msg.data);
            ensurePC();

            if (data.type === 'offer') {
              setCallStatus('remote', 'CONNECTING');
              await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'answer', answer: pc.localDescription }));
              }
            }

            if (data.type === 'answer') {
              await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
            }

            if (data.type === 'candidate') {
              try {
                await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
              } catch (err) {
                console.error('Error adding ICE candidate:', err);
              }
            }

            if (data.type === 'status') {
              setCallStatus('remote', data.status);
            }
          } catch (e) {
            console.error('WS message handling error:', e);
          }
        };
      } catch (e) {
        alert('WS 연결 실패: ' + e.message);
      }
    }

    /**
     * WebSocket 연결 종료
     */
    function disconnectWss() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        // 종료 상태 전송
        ws.send(JSON.stringify({ type: 'status', status: 'DISCONNECTED' }));
      }

      if (ws) {
        try { ws.close(); } catch {}
        ws = null;
        setWsStatus(false);
      }
      endCall()
    }
  
    /**
     * 통화 연결
     */
    async function startCall() {
      const overlay = document.getElementById('loadingOverlay');
      try {
        overlay.style.display = 'flex';

        // 권한 확인
        const cameraStatus = await navigator.permissions.query({ name: 'camera' });
        const microphoneStatus = await navigator.permissions.query({ name: 'microphone' });
        if (cameraStatus.state === 'denied') { 
          overlay.style.display = 'none';
          alert('카메라 권한이 거부되었습니다.'); 
          return; 
        }
        if (microphoneStatus.state === 'denied') { 
          overlay.style.display = 'none';
          alert('마이크 권한이 거부되었습니다.'); 
          return; 
        }

        // 미디어 장치 연결
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;

        // WebRTC 연결
        ensurePC();
        localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));

        // UX 상태 업데이트
        setButtonsDisabled(false);
        updateCallButtons(true);
        setCallStatus('local', 'WAITING');
        setCallStatus('remote', 'IDLE');
      } catch (e) {
        overlay.style.display = 'none';
        setCallStatus('local', 'error', e.message);
        alert('Error startCamera\n' + e.message);
      }
    }
    
    /**
     * 통화 종료
     */
    function endCall() {
      if (pc) {
        pc.close();
        pc = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      setCallStatus('local', 'DISCONNECTED');
      setCallStatus('remote', 'DISCONNECTED'); 

      setButtonsDisabled(true);
      updateCallButtons(false);
    }

    /**
     * 카메라 On/Off
     */
    function toggleCamera() {
      if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          videoTrack.enabled = !videoTrack.enabled;
        }
      }
    }

    /**
     * 오디오 On/Off
     */
    function toggleAudio() {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
        }
      }
    }

    
    // Offer 생성: 수동/WS 병행
    async function handleCreateOffer() {
      try {
        ensurePC();
        setCallStatus('local', 'CONNECTING');
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
    
        // WS 연결되어 있으면 추가로 전송
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'offer', offer: pc.localDescription }));
        }
      } catch (e) {
        alert('Offer 생성 실패: ' + e.message);
      }
    };
    
    window.addEventListener('DOMContentLoaded', () => {
      // UX 상태 업데이트
      setButtonsDisabled(true);
      updateCallButtons(false);
      setCallStatus('local', 'IDLE');
      setCallStatus('remote', 'IDLE');
    });
  </script>
</body>
</html>
