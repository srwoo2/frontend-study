<!DOCTYPE html>
<html lang="ko">
<head>
  <script src="/src/webrtc/js/common/set-title.js"></script>
  <script src="/src/webrtc/js/common/utils.js"></script>
</head>
  <style>
    :root {
      --bg-color: #202124;
      --text: #ffffff;
    }
    .video-box {
      position: relative;
    }
    #loadingOverlay {
      position: absolute !important; 
      top: 0; 
      left: 0;
      width: 100%; 
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 5;
    }
  </style>
</head>
<body>
  <div id="container">
    <div class="status-pill">
      <div><span id="localStatus">IDLE</span></div>
      <div style="margin-left: 10px; padding-left: 10px; border-left: 1px solid #555;">WS: <span id="wsStatus" style="color: red;">disconnected</span></div>
    </div>

    <div class="split-container">
      <div class="video-box">
        <div class="label">상대방 (Remote)</div>
        <video id="remoteVideo" autoplay playsinline></video>
        
        <div id="loadingOverlay" class="loading-overlay" style="display: none;">
          <div class="spinner"></div>
        </div>
      </div>
      <div class="video-box">
        <div class="label">나 (Local)</div>
        <video id="localVideo" autoplay playsinline muted></video>
      </div>
    </div>

    <div class="control-bar">
      <button id="startCallBtn" class="btn-primary" onclick="startCall()">통화 연결</button>
      <button id="endCallBtn" class="btn-danger" onclick="endCall(); disconnectWss();" disabled>통화 종료</button>
      <button id="toggleCameraBtn" class="btn-secondary" onclick="toggleCamera()" disabled>카메라</button>
      <button id="toggleAudioBtn" class="btn-secondary" onclick="toggleAudio()" disabled>마이크</button>
      <button id="connectWs" class="btn-secondary" onclick="connectWss()" disabled>Connect WS</button>
      <button id="createOfferBtn" class="btn-secondary createOffer" onclick="handleCreateOffer()" disabled>Create Offer</button>
      <button class="btn-secondary" onclick="document.getElementById('wsPanel').style.display = 'block'">WS 설정</button>
    </div>

    <div id="wsPanel" class="panel" style="display: none; position: absolute; top: 20%; left: 20%; width: 60%; background: rgba(32, 33, 36, 0.95); z-index: 100; border: 1px solid #444; color: #fff; padding: 20px;">
      <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #444; margin-bottom: 15px; padding-bottom: 10px;">
        <h3 style="margin: 0;">Signaling 설정</h3>
        <button class="btn-secondary" style="height: 32px; padding: 0 16px;" onclick="document.getElementById('wsPanel').style.display = 'none'">닫기</button>
      </div>
      <div class="row" style="margin-bottom: 15px; align-items: center;">
        <label style="margin-right: 10px;">WS URL:</label>
        <input id="wsUrl" type="text" style="flex: 1; height: 40px; background: #111; color: #fff; border: 1px solid #555; padding: 0 10px;" value="wss://192.168.2.95:3001" />
      </div>
      <p class="sub-text" style="color: #aaa;">
        - A와 B 모두 하단 WS URL 입력란이 wss://localhost:3001인지 확인 후 “Connect WS” 클릭하여 connected 확인<br/>
        - disconnected인 경우, <a href="#" style="color: #8ab4f8;" onclick="openTab('https://192.168.2.95:3001'); return false;">인증서 신뢰 설정</a> 필요
      </p>
    </div>
  </div>



  <script>
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const localStatus = document.getElementById('localStatus');

    const startCallBtn = document.getElementById('startCallBtn');
    const endCallBtn = document.getElementById('endCallBtn');
    const toggleCameraBtn = document.getElementById('toggleCameraBtn');
    const toggleAudioBtn = document.getElementById('toggleAudioBtn');

    const connectWsBtn = document.getElementById('connectWs');
    const createOfferBtns = document.querySelectorAll('.createOffer');

    const configuration = { iceServers: [] };

    let _call_state = WS_STATUS.IDLE.id;
    Object.defineProperty(window, 'ws_state', {
      get: function() { return _call_state; },
      set: function(val) {
        _call_state = val;
        updateUiForState();
      }
    });

    /**
     * socket 연결 상태 업데이트 함수
     */
    function setWsStatus(connected) {
      const wsStatusSpan = document.getElementById('wsStatus');
      wsStatusSpan.textContent = connected ? 'connected' : 'disconnected';
      wsStatusSpan.style.color = connected ? 'green' : 'red';
    }

    /**
     * 연결 상태 UI 표시
     */
    function updateUiForState() {
      const stateId = WS_STATUS[ws_state].id || '';

      // 상태에 따른 텍스트 표시
      const statusSpan = document.getElementById('localStatus');
      statusSpan.textContent = WS_STATUS[ws_state].label || '';

      // 초기화: 모든 버튼 숨김
      startCallBtn.style.display = 'none';
      endCallBtn.style.display = 'none';
      toggleCameraBtn.style.display = 'none';
      toggleAudioBtn.style.display = 'none';
      connectWsBtn.style.display = 'none';
      createOfferBtns.forEach(btn => btn.style.display = 'none');

      // 상태별 버튼 제어
      switch (stateId) {
        case WS_STATUS.IDLE.id:
          // IDLE 상태에서도 WS 연결이나 Offer 생성은 가능해야 함 (수동/WS 모드 특성상)
          connectWsBtn.style.display = 'inline-block';
          connectWsBtn.disabled = false;
          // startCall은 미디어 권한 획득 등을 포함하므로 WAITING으로 가는 진입점 역할
          startCallBtn.style.display = 'inline-block'; 
          startCallBtn.disabled = false;
          break;

        case WS_STATUS.WAITING.id:
          // 대기 상태: 통화 시작 가능
          startCallBtn.style.display = 'inline-block';
          startCallBtn.disabled = false;
          toggleAudioBtn.style.display = 'inline-block';
          toggleCameraBtn.style.display = 'inline-block';
          connectWsBtn.style.display = 'inline-block';
          connectWsBtn.disabled = false;
          createOfferBtns.forEach(btn => {
             btn.style.display = 'inline-block';
             btn.disabled = false;
          });
          break;

        case WS_STATUS.CONNECTING.id:
        case WS_STATUS.CONNECTED.id:
          endCallBtn.style.display = 'inline-block';
          endCallBtn.disabled = false;
          toggleAudioBtn.style.display = 'inline-block';
          toggleCameraBtn.style.display = 'inline-block';
          
          // 연결 중/통화 중에는 WS 연결/Offer 생성 숨김
          connectWsBtn.style.display = 'none'; 
          createOfferBtns.forEach(btn => btn.style.display = 'none');
          break;

        case WS_STATUS.DISCONNECTED.id:
        case WS_STATUS.ERROR.id:
          // 종료/오류 시 다시 시작 가능하도록
          startCallBtn.style.display = 'inline-block';
          startCallBtn.disabled = false;
          connectWsBtn.style.display = 'inline-block';
          connectWsBtn.disabled = false;
          break;

         default:
           break;
      }

      // 로딩 오버레이 제어
      const overlay = document.getElementById('loadingOverlay');
      if (stateId === WS_STATUS.CONNECTING.id) {
        overlay.style.display = 'flex';
      } else {
        overlay.style.display = 'none';
      }
    }

    /**
     * RTCPeerConnection이 없으면 생성하고, 원격 스트림 처리와 ICE 후보 수집/전송을 설정하는 함수
     */
    function ensurePC() {
      if (!pc) {
        pc = new RTCPeerConnection(configuration);

        const remoteStream = new MediaStream();
        remoteVideo.srcObject = remoteStream;
        pc.ontrack = (event) => {
          event.streams[0].getTracks().forEach((t) => remoteStream.addTrack(t));
        };

        // 로컬 ICE 후보: 수동 텍스트 + WS 전송 병행
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            // WS 연결 시 자동 전송
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
            }
          }
        };

        pc.oniceconnectionstatechange = () => {
          console.log('ICE state:', pc.iceConnectionState);
          switch (pc.iceConnectionState) {
            case 'checking':
              break;
            case 'connected':
            case 'completed':
              ws_state = WS_STATUS.CONNECTED.id;
              break;
            case 'failed':
              ws_state = WS_STATUS.ERROR.id;
              break;
            case 'disconnected':
            case 'closed':
              endCall(); // 상대방 연결이 끊어지면 내 통화도 종료
              break;
          }
        };
      }
    }

    /**
     * WebSocket 서버 URL 생성 함수 (항상 wss 사용)
     */
    function buildWssUrl(raw) {
      console.log(raw)

      const input = (raw || '').trim();
      const pageIsHttps = location.protocol === 'https:';
      const defaultHostname = location.hostname;
      const defaultPort = 3001;

      if (!input) {
        return `wss://${defaultHostname}:${defaultPort}`;
      }

      return input;
    }

    /**
     * WebSocket 연결
     */
    function connectWss() {
      if (ws && ws.readyState === WebSocket.OPEN) return;

      try {
        const wsUrlInput = document.getElementById('wsUrl');
        const targetUrl = buildWssUrl(wsUrlInput.value || '');

        ws = new WebSocket(targetUrl);
        ws.onopen = () => setWsStatus(true);
        ws.onclose = () => setWsStatus(false);

        ws.onerror = (e) => {
          setWsStatus(false);
          alert('WS 연결 오류. 인증서 신뢰 또는 네트워크/방화벽을 확인하세요.');
        };
  
        ws.onmessage = async (msg) => {
          try {
            const data = JSON.parse(msg.data);
            ensurePC();

            if (data.type === 'offer') {
               // Offer 수신 시 자동으로 응답 과정이 진행되므로 CONNECTING 상태로 전환
              ws_state = WS_STATUS.CONNECTING.id;

              await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'answer', answer: pc.localDescription }));
              }
            }

            if (data.type === 'answer') {
              await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
            }

            if (data.type === 'candidate') {
              try {
                await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
              } catch (err) {
                console.error('Error adding ICE candidate:', err);
              }
            }

            if (data.type === 'status') {
              // Remote 상태 표시는 제거됨
            }
          } catch (e) {
            console.error('WS message handling error:', e);
          }
        };
      } catch (e) {
        alert('WS 연결 실패: ' + e.message);
      }
    }

    /**
     * WebSocket 연결 종료
     */
    function disconnectWss() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        // 종료 상태 전송
        ws.send(JSON.stringify({ type: 'status', status: 'DISCONNECTED' }));
      }

      if (ws) {
        try { ws.close(); } catch {}
        ws = null;
        setWsStatus(false);
      }
      endCall()
    }
  
    /**
     * 통화 연결
     */
    async function startCall() {
      const overlay = document.getElementById('loadingOverlay');
      try {
        overlay.style.display = 'flex';

        // 권한 확인
        const cameraStatus = await navigator.permissions.query({ name: 'camera' });
        const microphoneStatus = await navigator.permissions.query({ name: 'microphone' });
        if (cameraStatus.state === 'denied') { 
          overlay.style.display = 'none';
          alert('카메라 권한이 거부되었습니다.'); 
          return; 
        }
        if (microphoneStatus.state === 'denied') { 
          overlay.style.display = 'none';
          alert('마이크 권한이 거부되었습니다.'); 
          return; 
        }

        // 미디어 장치 연결
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;

        // WebRTC 연결
        ensurePC();
        localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));

        // UX 상태 업데이트
        ws_state = WS_STATUS.WAITING.id;
      } catch (e) {
        console.error(e);
        alert('Error startCall\n' + e.message);
        ws_state = WS_STATUS.ERROR.id;
      }
    }
    
    /**
     * 통화 종료
     */
    function endCall() {
      if (pc) {
        pc.close();
        pc = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      ws_state = WS_STATUS.DISCONNECTED.id; 
    }

    /**
     * 카메라 On/Off
     */
    function toggleCamera() {
      if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          videoTrack.enabled = !videoTrack.enabled;
        }
      }
    }

    /**
     * 오디오 On/Off
     */
    function toggleAudio() {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
        }
      }
    }

    
    // Offer 생성: 수동/WS 병행
    async function handleCreateOffer() {
      try {
        ensurePC();
        ws_state = WS_STATUS.CONNECTING.id;
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
    
        // WS 연결되어 있으면 추가로 전송
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'offer', offer: pc.localDescription }));
        }
      } catch (e) {
        alert('Offer 생성 실패: ' + e.message);
      }
    };
    
    window.addEventListener('DOMContentLoaded', () => {
      // UX 상태 업데이트
      ws_state = WS_STATUS.IDLE.id;
    });
  </script>
</body>
</html>
